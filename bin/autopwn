#!/bin/bash
# Auto-PWN: Automated vulnerability detection and exploitation
if [ $# -eq 0 ]; then
    echo "Usage: autopwn <binary>"
    exit 1
fi

BINARY=$1
echo "[*] Analyzing $BINARY..."

# 检查二进制文件是否存在
if [ ! -f "$BINARY" ]; then
    echo "[!] Error: Binary file not found!"
    exit 1
fi

# 检查安全特性
echo "[*] Security features:"
if command -v checksec &> /dev/null; then
    checksec --file="$BINARY"
else
    echo "[!] checksec not found. Installing security checks manually..."
    # 手动检查安全特性
    echo "  - NX: $(readelf -l "$BINARY" | grep -q "GNU_STACK" && echo "Enabled" || echo "Disabled")"
    echo "  - PIE: $(readelf -h "$BINARY" | grep -q "DYN" && echo "Enabled" || echo "Disabled")"
    echo "  - Canary: $(readelf -s "$BINARY" | grep -q "__stack_chk_fail" && echo "Enabled" || echo "Disabled")"
    echo "  - RELRO: $(readelf -d "$BINARY" | grep -q "BIND_NOW" && echo "Full" || (readelf -d "$BINARY" | grep -q "GNU_RELRO" && echo "Partial" || echo "Disabled"))"
fi

# 检查常见漏洞
echo -e "\n[*] Checking for vulnerabilities..."

# 格式字符串漏洞
if strings "$BINARY" | grep -q "%s\|%x\|%p\|%n"; then
    echo "[!] Possible format string vulnerability detected"
    echo "    - Found format string specifiers: $(strings "$BINARY" | grep -E "%[0-9]*s|%[0-9]*x|%[0-9]*p|%n" | head -5)"
fi

# 缓冲区溢出
UNSAFE_FUNCS=("gets" "strcpy" "strcat" "sprintf" "scanf" "vsprintf" "strncpy" "strncat")
for func in "${UNSAFE_FUNCS[@]}"; do
    if objdump -d "$BINARY" 2>/dev/null | grep -q "$func"; then
        echo "[!] Possible buffer overflow vulnerability detected"
        echo "    - Unsafe function: $func"
    fi
done

# Use-after-free
if objdump -d "$BINARY" 2>/dev/null | grep -q "free"; then
    echo "[!] Check for use-after-free vulnerabilities"
    echo "    - Found free() calls: $(objdump -d "$BINARY" | grep -c "free")"
fi

# 整数溢出
if objdump -d "$BINARY" 2>/dev/null | grep -q "malloc\|calloc\|realloc"; then
    echo "[!] Check for integer overflow in size calculations"
    echo "    - Found memory allocation functions"
fi

# 检查架构
ARCH=$(file "$BINARY" | grep -oE "32-bit|64-bit")
echo -e "\n[*] Architecture: $ARCH"

# 查找ROP gadgets
echo -e "\n[*] Searching for ROP gadgets..."
if command -v ropper &> /dev/null; then
    ropper --file "$BINARY" --nocolor > /tmp/rop_gadgets.txt
    echo "[+] Found $(wc -l < /tmp/rop_gadgets.txt) ROP gadgets"
    
    # 查找有用的gadgets
    echo -e "\n[*] Useful ROP gadgets:"
    echo "  - Pop rdi: $(grep -m1 "pop rdi" /tmp/rop_gadgets.txt || echo "Not found")"
    echo "  - Pop rsi: $(grep -m1 "pop rsi" /tmp/rop_gadgets.txt || echo "Not found")"
    echo "  - Pop rdx: $(grep -m1 "pop rdx" /tmp/rop_gadgets.txt || echo "Not found")"
    echo "  - Syscall: $(grep -m1 "syscall" /tmp/rop_gadgets.txt || echo "Not found")"
    echo "  - Ret: $(grep -m1 "ret" /tmp/rop_gadgets.txt || echo "Not found")"
    
    # 查找write/puts gadgets
    echo "  - Write gadget: $(grep -m1 "write" /tmp/rop_gadgets.txt || echo "Not found")"
    echo "  - Puts gadget: $(grep -m1 "puts" /tmp/rop_gadgets.txt || echo "Not found")"
else
    echo "[!] ropper not found. Skipping ROP gadget search."
fi

# 检查符号信息
echo -e "\n[*] Symbol information:"
if readelf -s "$BINARY" 2>/dev/null | grep -q "FUNC"; then
    echo "  - Function symbols found"
    readelf -s "$BINARY" | grep "FUNC" | awk '{print "    " $8 " @ " $2}' | head -10
else
    echo "  - No function symbols found (stripped binary)"
fi

# 检查字符串信息
echo -e "\n[*] Interesting strings:"
strings "$BINARY" | grep -E "/bin/sh|sh|flag|password|secret" | head -10 | sed 's/^/    /'

# 生成利用脚本模板
echo -e "\n[*] Generating exploit template..."
cat > exploit.py << EOF
#!/usr/bin/env python3
from pwn import *

# 设置目标二进制文件
context.binary = '$BINARY'
context.log_level = 'debug'

# 启动进程
p = process('./$BINARY')
# p = remote('host', port)  # 用于远程利用

# 漏洞利用部分
def exploit():
    # 1. 确定偏移量
    # payload = cyclic(100)  # 用于测试偏移量
    # p.sendline(payload)
    # p.wait()
    # core = p.corefile
    # offset = cyclic_find(core.pc)
    # log.info(f"Offset found at: {offset}")

    # 2. 构建ROP链
    # rop = ROP(context.binary)
    # rop.raw(cyclic(offset))
    # rop.call(rop.ret)  # 对齐栈
    # rop.call('puts', [next(context.binary.search(b'/bin/sh'))])
    # rop.call('system', [next(context.binary.search(b'/bin/sh'))])
    
    # 3. 发送payload
    # p.sendline(rop.chain())
    # p.interactive()

if __name__ == "__main__":
    exploit()
EOF

echo "[+] Exploit template saved to exploit.py"
chmod +x exploit.py

# 检查是否有调试符号
echo -e "\n[*] Debugging information:"
if gdb -batch -ex "info symbol main" "$BINARY" 2>/dev/null | grep -q "main"; then
    echo "  - Debug symbols present"
else
    echo "  - No debug symbols found"
fi

# 检查ASLR状态
echo -e "\n[*] System ASLR status:"
if [ -f /proc/sys/kernel/randomize_va_space ]; then
    ASLR=$(cat /proc/sys/kernel/randomize_va_space)
    case $ASLR in
        0) echo "  - ASLR: Disabled";;
        1) echo "  - ASLR: Partial (Conservative)";;
        2) echo "  - ASLR: Full (Default)";;
    esac
else
    echo "  - ASLR status: Unknown"
fi

# 检查可执行栈
echo -e "\n[*] Executable stack:"
if readelf -l "$BINARY" | grep -q "GNU_STACK.*RWE"; then
    echo "  - Stack is executable (shellcode possible)"
else
    echo "  - Stack is not executable (NX enabled)"
fi

# 检查共享库
echo -e "\n[*] Shared libraries:"
if ldd "$BINARY" 2>/dev/null | grep -q "=>"; then
    ldd "$BINARY" | awk '{print "    " $1 " => " $3}'
else
    echo "  - Statically linked binary"
fi

# 检查内存保护
echo -e "\n[*] Memory protection:"
if command -v gdb &> /dev/null; then
    gdb -batch -ex "start" -ex "info proc mappings" -ex "quit" "$BINARY" 2>/dev/null | grep -E "0x.*[rwx].*" | head -10 | sed 's/^/    /'
else
    echo "  - GDB not found, skipping memory mapping check"
fi

# 最终建议
echo -e "\n[*] Recommendations:"
echo "  1. Use GEF/pwndbg for dynamic analysis"
echo "  2. Test with custom input patterns"
echo "  3. Check for memory leaks"
echo "  4. Analyze control flow with IDA/Ghidra"
echo "  5. Use exploit.py as starting point"
echo "  6. Consider using pwntools for exploit development"

echo -e "\n[*] Analysis complete. Check exploit.py for starting point."